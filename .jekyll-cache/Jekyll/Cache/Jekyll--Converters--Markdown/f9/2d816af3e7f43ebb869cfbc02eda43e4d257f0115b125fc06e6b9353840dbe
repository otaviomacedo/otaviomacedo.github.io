I"*,<script type="text/javascript" async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?
config=TeX-AMS-MML_HTMLorMML"></script>

<h2 id="program-design">Program design</h2>

<p>The game is structured into three main abstractions: Board, Game and Player, of which we have two implementations: Computer and User. Conceptually, a game starts with two players and an empty board and unravels it. In other words, it generates a sequence of states (the different board configurations as the game progresses, from beginning to end) corresponding to the alternating moves of the two players.</p>

<p><img src="/assets/ttt-design.png" alt="" /></p>

<p>Let’s focus on the Board. As the name suggests, it describes a configuration of the game’s board, that is, which marks are placed on which positions. For example, a particular instance of Board could have the configuration below:</p>

<!-- ![Image showing a winning configuration]() -->

<p>The main question we want Board to answer is: given this configuration, who is the winner (if any)? We can implement this by applying two consecutive transformations to the data:</p>

<!-- ![Image showing the transformations: blue and green]() -->

<p>In the blue transformation, given a sequence of marks, if they are all equal, we want to output that mark; otherwise, the mark representing the empty cell. In the green transformation, given a sequence of marks, we want to output the first one that we find that is not the empty cell (given the rules of the game, there can be at most one such mark); otherwise, the mark representing the empty cell.</p>

<p>A possible implementation of this process in Scala is:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">lazy</span> <span class="k">val</span> <span class="nv">outcome</span><span class="k">:</span> <span class="kt">GameOutcome</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">product</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">GameOutcome</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">GameOutcome</span><span class="o">)</span><span class="k">:</span> <span class="kt">GameOutcome</span> <span class="o">=</span> 
    <span class="nf">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="nc">None</span>

  <span class="k">def</span> <span class="nf">winner</span><span class="o">(</span><span class="n">positions</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">GameOutcome</span> <span class="o">=</span> 
    <span class="n">positions</span> <span class="n">map</span> <span class="n">cells</span> <span class="n">reduce</span> <span class="n">product</span>

  <span class="k">val</span> <span class="nv">allLines</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="n">rows</span><span class="o">,</span> <span class="n">columns</span><span class="o">,</span> <span class="n">diagonals</span><span class="o">).</span><span class="py">flatten</span>
  <span class="n">allLines</span> <span class="n">map</span> <span class="n">winner</span> <span class="nf">find</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">isDefined</span><span class="o">)</span> <span class="n">getOrElse</span> <span class="nc">None</span>
<span class="o">}</span>
</code></pre></div></div>
<!-- Briefly talk about the types: GameOutcome, Symbol -->

<p>This is perfectly fine. The function <code class="language-plaintext highlighter-rouge">product</code> corresponds to the blue transformation in our diagram and <code class="language-plaintext highlighter-rouge">find(_.isDefined) getOrElse None</code> in the last line corresponds to the green one. This is the intuitive notion we have about what should happen and more or less matches the verbal description I’ve given for it. But there is a deeper connection between these two transformations that is lost in this implementation.</p>

<p>First off, we use <code class="language-plaintext highlighter-rouge">reduce</code> to go from a sequence of symbols to a single symbol in the blue transformation. It would be satisfyingly symmetrical if we could reframe the green one in term of reduction, as well. So, what would that function look like? With a bit of thought and experimentation, we can quickly arrive at the solution. But I would like to take a detour through the land of Abstract Algebra and Order Theory.</p>

<h2 id="semilattices">Semilattices</h2>

<p>The function <code class="language-plaintext highlighter-rouge">product</code> is a lot more interesting than it seems. Before we can take a closer look at it, though, I want to just adopt a different convention for this section, to make the text more readable: I’m replacing the name <code class="language-plaintext highlighter-rouge">product</code> with the symbol \(\ast\) and, whenever you see \(a \ast b\), translate it in your mind to <code class="language-plaintext highlighter-rouge">product(a, b)</code>.</p>

<p>Ok, so the operation \(\ast\) has three noteworthy properties:</p>

<ul>
  <li><strong>Idempotence</strong>: \(a \ast a = a\) for any symbol \(a\). This is the very reason we created this function.</li>
  <li><strong>Commutativity</strong>: \(a \ast b = b \ast a\) for any two symbols \(a\) and \(b\).</li>
  <li><strong>Associativity</strong>:  \((a \ast b) \ast c = a \ast (b \ast c)\) for any three symbols \(a\), \(b\) and \(c\).</li>
</ul>

<p>In Abstract Algebra, a set with an operation that satisfies these three properties form a structure called <em>semilattice</em>. The interesting thing about a semilattice is that they can be looked at from two different perspectives: as a set with an operation, as we just saw, or as a <em>partially ordered set</em>.</p>

<p>To understand what this means, consider all the possible pairs of symbols. There are \(3\) different symbols, so \(3^2 = 9\) combinations. Out of these \(9\) pairs, let’s keep only those in which the product of the two elements is equal to the first one. For example, the pair \((\epsilon, {\normalsize\texttt{o}})\) satisfies this condition because \(\epsilon \ast {\normalsize\texttt{o}} = \epsilon\), whereas \(({\normalsize\texttt{o}}, \epsilon)\) and \((\times, {\normalsize\texttt{o}})\) don’t. If a given pair \((a, b)\) satisfies this condition, we say that \(a \leq b\).</p>

<p>So, starting from the semilattice operation, we defined what “less than or equal to” means. And, if we know that \(a \leq b\), and we had to put them in order, \(a\) would come first. So, the “ordered” part is clear. In what sense, then, is it “partially” ordered? This refers to the fact that some pairs of elements cannot be compared this way. For example, neither \(\times \leq {\normalsize\texttt{o}}\) nor \({\normalsize\texttt{o}} \leq \times\) is true.</p>

<p>One of the logical consequences of this particular partial order (we could have a different order had we started with a different operation) is that \(\epsilon \leq x\) for any symbol \(x\).</p>

<p>But, despite the fact that some pairs of symbols cannot be compared, it’s still reasonable to ask the question: given any two symbols, which of them is not less than or equal to the other? (Note how I carefully avoided saying “greater than”.) In particular, if they are not comparable, the answer to this question is: both of them. This is called a <em>maximal</em> element of the subset.</p>

<h2 id="back-to-code">Back to code</h2>

<p>With this theory in mind, we can now reframe the second transformation in terms of finding a maximal of a sequence of symbols. Previously we were looking for a defined element in a sequence and, if we didn’t find any, we would return <code class="language-plaintext highlighter-rouge">None</code>. Given the definition above</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">lazy</span> <span class="k">val</span> <span class="nv">outcome</span><span class="k">:</span> <span class="kt">GameOutcome</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">product</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">GameOutcome</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">GameOutcome</span><span class="o">)</span><span class="k">:</span> <span class="kt">GameOutcome</span> <span class="o">=</span> 
    <span class="nf">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="nc">None</span>

  <span class="k">def</span> <span class="nf">maximal</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">GameOutcome</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">GameOutcome</span><span class="o">)</span><span class="k">:</span> <span class="kt">GameOutcome</span> <span class="o">=</span> 
    <span class="nf">if</span> <span class="o">(</span><span class="nf">product</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">==</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="k">else</span> <span class="n">a</span>

  <span class="k">def</span> <span class="nf">winner</span><span class="o">(</span><span class="n">positions</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">GameOutcome</span> <span class="o">=</span> 
    <span class="n">positions</span> <span class="n">map</span> <span class="n">cells</span> <span class="n">reduce</span> <span class="n">product</span>

  <span class="k">val</span> <span class="nv">allLines</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="n">rows</span><span class="o">,</span> <span class="n">columns</span><span class="o">,</span> <span class="n">diagonals</span><span class="o">).</span><span class="py">flatten</span>
  <span class="n">allLines</span> <span class="n">map</span> <span class="n">winner</span> <span class="n">reduce</span> <span class="n">maximal</span>
<span class="o">}</span>
</code></pre></div></div>

<!-- TODO Make this statement stronger and more interesting -->
<p>Of course, if this was a real world application, I wouldn’t do this refactoring. The previous version communicates intent much better, even if we lose some symmetry. But this example shows just how often abstract algebraic structures like semilattices appear everywehere.</p>

:ET