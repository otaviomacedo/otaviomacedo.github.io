<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Functions and Regular Expressions | Otavio Macedo</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Functions and Regular Expressions" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Regular expressions are one of those things that bring joy and frustration at the same time to most software developers. At one point or another, we’ve all written functions to match strings against some regular expression, as part of a bigger function, class, component etc. In this post, I want to show you one of the counterintuitive results from Computability Theory, that involves regular expressions. The code samples are all in Scala, mainly because, in my opinion, it is concise in many respects, but, at the same time, reasonably familiar to a wide audience of developers." />
<meta property="og:description" content="Regular expressions are one of those things that bring joy and frustration at the same time to most software developers. At one point or another, we’ve all written functions to match strings against some regular expression, as part of a bigger function, class, component etc. In this post, I want to show you one of the counterintuitive results from Computability Theory, that involves regular expressions. The code samples are all in Scala, mainly because, in my opinion, it is concise in many respects, but, at the same time, reasonably familiar to a wide audience of developers." />
<link rel="canonical" href="http://localhost:4000/decidability/2020/12/11/regex.html" />
<meta property="og:url" content="http://localhost:4000/decidability/2020/12/11/regex.html" />
<meta property="og:site_name" content="Otavio Macedo" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-12-11T13:40:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Functions and Regular Expressions" />
<script type="application/ld+json">
{"url":"http://localhost:4000/decidability/2020/12/11/regex.html","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/decidability/2020/12/11/regex.html"},"datePublished":"2020-12-11T13:40:00+00:00","headline":"Functions and Regular Expressions","dateModified":"2020-12-11T13:40:00+00:00","description":"Regular expressions are one of those things that bring joy and frustration at the same time to most software developers. At one point or another, we’ve all written functions to match strings against some regular expression, as part of a bigger function, class, component etc. In this post, I want to show you one of the counterintuitive results from Computability Theory, that involves regular expressions. The code samples are all in Scala, mainly because, in my opinion, it is concise in many respects, but, at the same time, reasonably familiar to a wide audience of developers.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Otavio Macedo" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Otavio Macedo</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Functions and Regular Expressions</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-12-11T13:40:00+00:00" itemprop="datePublished">Dec 11, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Regular expressions are one of those things that bring joy and frustration at the same time to most software developers. At one point or another, we’ve all written functions to match strings against some regular expression, as part of a bigger function, class, component etc. In this post, I want to show you one of the counterintuitive results from Computability Theory, that involves regular expressions. The code samples are all in Scala, mainly because, in my opinion, it is concise in many respects, but, at the same time, reasonably familiar to a wide audience of developers.</p>

<h2 id="terminology">Terminology</h2>

<p>Let’s start with some basic Computer Science terminology. If you are familiar with these terms, feel free to skip to the next section.</p>

<p>A <strong>language</strong> is any set of strings. A <strong>regular language</strong> is a set of strings that match some regular expression. Conversely, a <strong>non-regular language</strong> is a language for which there is no regular expression that matches all the strings in it.</p>

<p>A function <strong>accepts</strong> a string if it returns <code class="language-plaintext highlighter-rouge">true</code> for that string<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup>. And we say that a function <strong>recognizes</strong> a language if it returns <code class="language-plaintext highlighter-rouge">true</code> for all strings in that language and <code class="language-plaintext highlighter-rouge">false</code> for all others. Some functions, however, can go into an infinite loop and therefore never return either  <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code> for some strings. These functions are obviously undesirable. We are usually more interested in functions that eventually terminate. We call them <strong>deciders</strong>. When a decider recognizes a language, we say that it <strong>decides</strong> that language.</p>

<p>Ok, that’s all we need to define for this article.</p>

<h2 id="different-classes-of-functions">Different classes of functions</h2>

<p>So let’s say we want to implement a function to recognize the regular language 01<sup>*</sup>0. That is, the set of all strings that start and end with a 0, with any number of 1s (including none) in the middle. Pretty straightforward to do, using Scala’s built-in regular expression support:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">zerosAtTheEdges</span> <span class="nf">extends</span> <span class="o">(</span><span class="nc">String</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="nv">s</span><span class="o">.</span><span class="py">matches</span><span class="o">(</span><span class="s">"01*0"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Another (trivial) example of a regular language is the set of all strings:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">anything</span> <span class="nf">extends</span> <span class="o">(</span><span class="nc">String</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="nv">s</span><span class="o">.</span><span class="py">matches</span><span class="o">(</span><span class="s">"[01]*"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We can also implement a function to recognize non-regular languages, such as 0<sup><em>n</em></sup>1<sup><em>n</em></sup>. This language is composed of all the strings that start with a certain number of 0s and end with the same number of 1s. How do we know that this language is non-regular? The intuition is basically this: in order to tell whether a string has an equal number of 0s and 1s, you need to count their occurrences. So you need to store this information in memory, somehow. Since the exponent <em>n</em> can be arbitrarily large, we need an arbitrarily large memory. But, when it comes to regular expressions, we can only rely on a finite, pre-determined memory (for example, we can write a regular expression for 0<sup>3</sup>1<sup>3</sup> or 0<sup>4</sup>1<sup>4</sup> or any other <em>fixed</em> number, but not an arbitrarily large number).</p>

<p>A possible implementation of a function that recognizes 0<sup><em>n</em></sup>1<sup><em>n</em></sup> is:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">zerosAndOnes</span> <span class="nf">extends</span> <span class="o">(</span><span class="nc">String</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">val</span> <span class="o">(</span><span class="n">zeros</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="k">=</span> <span class="nv">s</span><span class="o">.</span><span class="py">span</span><span class="o">(</span><span class="k">_</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">)</span>
    <span class="nv">zeros</span><span class="o">.</span><span class="py">length</span> <span class="o">==</span> <span class="nv">rest</span><span class="o">.</span><span class="py">length</span> <span class="o">&amp;&amp;</span> <span class="nv">rest</span><span class="o">.</span><span class="py">forall</span><span class="o">(</span><span class="k">_</span> <span class="o">==</span> <span class="sc">'1'</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Some functions may accept or reject certain strings, but go into an infinite loop for all other strings:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">loop</span> <span class="nf">extends</span> <span class="o">(</span><span class="nc">String</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">if</span> <span class="o">(</span><span class="s">"0000"</span> <span class="n">equals</span> <span class="n">s</span><span class="o">)</span> <span class="kc">true</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="nf">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{}</span>
      <span class="kc">false</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Wouldn’t it be nice if we could implement some function <code class="language-plaintext highlighter-rouge">f</code> that received another function <code class="language-plaintext highlighter-rouge">g</code> as input (after all, Scala makes it easier to deal with higher-order functions) and decided whether <code class="language-plaintext highlighter-rouge">g</code> recognizes a regular language? This doesn’t seem like an easy task, but let’s sketch out something to get a feel of what it would look like:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Given a function as input, tells whether 
 * that function recognizes a regular language.
 */</span>
<span class="k">object</span> <span class="nc">regularLanguageDecider</span> <span class="nf">extends</span> <span class="o">((</span><span class="nc">String</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">g</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
    <span class="n">g</span> <span class="o">==</span> <span class="n">zerosAtTheEdges</span> <span class="o">||</span> <span class="n">g</span> <span class="o">==</span> <span class="n">anything</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Obviously we’re cheating here. We’re assuming that there are only two regular languages in our universe and, for each of these languages, there is only one function that recognizes it. So all we need to do is check the identity of the function to reach a decision.</p>

<p>If you’re uncomfortable with this cheap trick, you can think of more sophisticated ways of inspecting the function <code class="language-plaintext highlighter-rouge">g</code>. You could consider, for example, using more advanced language features such as reflection or make the decider work on the source code of <code class="language-plaintext highlighter-rouge">g</code>, so you could do some static analysis and so on.</p>

<p>Regardless of how we think we might implement it, let’s just assume that such a decider already exists and is available in some open source library. We can just import that function in our own code and use it as we see fit. So, from now on, we will not look at its implementation anymore and just treat it as a black box that can be used wherever it’s needed.</p>

<h2 id="a-universal-decider">A Universal Decider</h2>

<p>Let’s now consider a different problem: we want to tell whether a function — any function — accepts a given string as input. For example, we know that <code class="language-plaintext highlighter-rouge">zerosAtTheEdges</code> accepts the strings “00”, “010”, “0110” and so on; and it doesn’t accept strings like “11” and “000”. In the first case, the function returns <code class="language-plaintext highlighter-rouge">true</code> and, in the second case, it returns <code class="language-plaintext highlighter-rouge">false</code>. Similarly, <code class="language-plaintext highlighter-rouge">loop</code> accepts the string “0000”, but doesn’t accept any other string (because, in that case, it goes into an infinite loop).</p>

<p>Can we implement a function to solve this problem? Let’s approach this with a Software Engineering mindset. Let’s think of the possible cases, write one test for each case at a time, see each test fail and then implement the code to make it pass, doing refactorings along the way, as necessary (a.k.a, Test Driven Development). So our first test would look like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">test</span><span class="o">(</span><span class="s">"Function accepts its input"</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">decider</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">UniversalDecider</span><span class="o">()</span>

  <span class="nf">assert</span><span class="o">(</span><span class="nv">decider</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">zerosAtTheEdges</span><span class="o">,</span> <span class="s">"01110"</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In this first test, we pass two parameters to our system under test: <code class="language-plaintext highlighter-rouge">zerosAtTheEdges</code> and <code class="language-plaintext highlighter-rouge">"01110"</code>. Since we know beforehand that <code class="language-plaintext highlighter-rouge">zerosAtTheEdges("01110") == true</code>, our test expects that <code class="language-plaintext highlighter-rouge">decider.apply()</code> returns <code class="language-plaintext highlighter-rouge">true</code>. An obvious way to make this test pass is:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UniversalDecider</span><span class="o">()</span> <span class="nf">extends</span> <span class="o">((</span><span class="nc">String</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">,</span> <span class="nc">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">fn</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span> <span class="o">=&gt;</span> <span class="kt">Boolean</span><span class="o">),</span> <span class="n">input</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> 
    <span class="nf">fn</span><span class="o">(</span><span class="n">input</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We simply pass the input to the function and return the result! Cool, let’s write our second test, then:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">test</span><span class="o">(</span><span class="s">"Function does not accept its input"</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">decider</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">UniversalDecider</span><span class="o">()</span>

  <span class="nf">assert</span><span class="o">(!</span><span class="nv">decider</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">zerosAtTheEdges</span><span class="o">,</span> <span class="s">"11"</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Without any modification to <code class="language-plaintext highlighter-rouge">UniversalDecider</code>, this test already passes. Things are looking good! Let’s move on to our third and final test:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">test</span><span class="o">(</span><span class="s">"Infinite loop"</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">decider</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">UniversalDecider</span><span class="o">()</span>

  <span class="nf">assert</span><span class="o">(!</span><span class="nv">decider</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">loop</span><span class="o">,</span> <span class="s">"11"</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We know that <code class="language-plaintext highlighter-rouge">loop</code> will never terminate when called with the string <code class="language-plaintext highlighter-rouge">"11"</code>, in which case <code class="language-plaintext highlighter-rouge">decider</code> should terminate with the value <code class="language-plaintext highlighter-rouge">false</code>. However, <code class="language-plaintext highlighter-rouge">decider</code> itself goes into an infinite loop, so our test will eventually fail with a timeout. But all is not lost. We can add a new level of indirection to our code, based on the Factory design pattern:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Factory</span> <span class="nf">extends</span> <span class="o">((</span><span class="nc">String</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">,</span> <span class="nc">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">String</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">))</span>
</code></pre></div></div>

<p>This factory receives two parameters, a function and a string, and returns another function. Implementations of this trait should fulfill the following contract:</p>

<ul>
  <li>If the function in the first parameter accepts the string in the second parameter, the resulting function (the factory’s product, so to speak) recognizes some regular language. It doesn’t matter which regular language is recognized by this function.</li>
  <li>Otherwise, the resulting function does not accept any regular language.</li>
</ul>

<p>Using the idea of Design by Contract, we can rely on this guarantee without having to know anything about any particular implementations of this factory.</p>

<p>OK, so how does this help us? Remember the regular language decider we’ve built before? It will come in handy now. Let’s refactor <code class="language-plaintext highlighter-rouge">UniversalDecider</code> to this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UniversalDecider</span><span class="o">(</span><span class="n">factory</span><span class="k">:</span> <span class="kt">Factory</span><span class="o">)</span> <span class="nf">extends</span> <span class="o">((</span><span class="nc">String</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">,</span> <span class="nc">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">fn</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span> <span class="o">=&gt;</span> <span class="kt">Boolean</span><span class="o">),</span> <span class="n">input</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
    <span class="nf">regularLanguageDecider</span><span class="o">(</span><span class="nf">factory</span><span class="o">(</span><span class="n">fn</span><span class="o">,</span> <span class="n">input</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We are now injecting the factory into <code class="language-plaintext highlighter-rouge">UniversalDecider</code>’s constructor. It’s easier to understand what’s going on here by looking at it graphically. We can group our three test cases into two scenarios:</p>

<p><img src="/assets/accept.svg" alt="Function accepts the input string" /></p>

<p><img src="/assets/not_accept.svg" alt="Function does not accept the input string" /></p>

<p>In the first scenario, <code class="language-plaintext highlighter-rouge">fn</code> accepts <code class="language-plaintext highlighter-rouge">input</code>. The first step is to feed these two parameters to the factory. Given the contract of the factory, it will produce a function that recognizes some regular language. The next step is to feed this function to <code class="language-plaintext highlighter-rouge">regularLanguageDecider</code>, which, according to its specification, returns <code class="language-plaintext highlighter-rouge">true</code> in this case. And this is the final result of <code class="language-plaintext highlighter-rouge">UniversalDecider</code>.</p>

<p>In the second scenario, <code class="language-plaintext highlighter-rouge">fn</code> doesn’t accept <code class="language-plaintext highlighter-rouge">input</code>, which makes the factory return a function that doesn’t accept a regular language, which makes <code class="language-plaintext highlighter-rouge">regularLanguageDecider</code> return <code class="language-plaintext highlighter-rouge">false</code>, which is the final result.</p>

<p>Now we need to refactor our tests accordingly, passing different mock implementations of the factory, depending on the test case:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">test</span><span class="o">(</span><span class="s">"Function accepts its input"</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">decider</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">UniversalDecider</span><span class="o">((</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">zerosAtTheEdges</span><span class="o">)</span>

  <span class="nf">assert</span><span class="o">(</span><span class="nv">decider</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">zerosAtTheEdges</span><span class="o">,</span> <span class="s">"01110"</span><span class="o">))</span>
<span class="o">}</span>

<span class="nf">test</span><span class="o">(</span><span class="s">"Function does not accept its input"</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">decider</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">UniversalDecider</span><span class="o">((</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">zerosAndOnes</span><span class="o">)</span>

  <span class="nf">assert</span><span class="o">(!</span><span class="nv">decider</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">zerosAtTheEdges</span><span class="o">,</span> <span class="s">"11"</span><span class="o">))</span>
<span class="o">}</span>

<span class="nf">test</span><span class="o">(</span><span class="s">"Function loops forever"</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">decider</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">UniversalDecider</span><span class="o">((</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">zerosAndOnes</span><span class="o">)</span>

  <span class="nf">assert</span><span class="o">(!</span><span class="nv">decider</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">loop</span><span class="o">,</span> <span class="s">"11"</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In the first test, we are injecting into <code class="language-plaintext highlighter-rouge">UniversalDecider</code> a mock factory that returns <code class="language-plaintext highlighter-rouge">zerosAtTheEdges</code>, which is a function that accepts the regular language, 01<sup>*</sup>0, which makes <code class="language-plaintext highlighter-rouge">decider</code> return <code class="language-plaintext highlighter-rouge">true</code>. In the other two cases, we are injecting <code class="language-plaintext highlighter-rouge">zerosAndOnes</code>, which accepts a non-regular language, 0<sup><em>n</em></sup>1<sup><em>n</em></sup>. This makes <code class="language-plaintext highlighter-rouge">decider</code> return <code class="language-plaintext highlighter-rouge">false</code>. Run the tests again and everything is green! Fantastic!</p>

<p>Except that… well, what have we actually accomplished with this? It seems that we just moved the problem somewhere else. We are delegating the hard work to this factory, that we have mocked for the unit tests, but we have no idea how to implement. But notice how the problem is simpler, now. The contract says that, if the input function accepts the string, the output function should accept a regular language. But if the input function does not accept the string, the output function can do <em>whatever it wants</em>, as long as it does not accept a regular language. So consider this implementation of <code class="language-plaintext highlighter-rouge">Factory</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">nonRegularOrDelegate</span> <span class="k">extends</span> <span class="nc">Factory</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">,</span> <span class="n">w</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span> <span class="o">=&gt;</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">zerosAndOnes</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">||</span> <span class="nf">f</span><span class="o">(</span><span class="n">w</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The output function can behave in four different ways, depending on the pair (<code class="language-plaintext highlighter-rouge">f</code>, <code class="language-plaintext highlighter-rouge">w</code>) used to create it and the input string <code class="language-plaintext highlighter-rouge">s</code> passed to it at runtime:</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th><code class="language-plaintext highlighter-rouge">f</code> accepts <code class="language-plaintext highlighter-rouge">w</code></th>
      <th><code class="language-plaintext highlighter-rouge">f</code>  does not accept  <code class="language-plaintext highlighter-rouge">w</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">s</code> matches 0<sup><em>n</em></sup>1<sup><em>n</em></sup></td>
      <td>Accept</td>
      <td>Accept</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">s</code> does not match 0<sup><em>n</em></sup>1<sup><em>n</em></sup></td>
      <td>Accept</td>
      <td>Reject or Loop</td>
    </tr>
    <tr>
      <td>Recognizes a regular language</td>
      <td><strong>Yes</strong></td>
      <td><strong>No</strong></td>
    </tr>
  </tbody>
</table>

<p>If you focus on the columns of this table, you’ll see that the last two correspond to the two different types of functions that can be generated. When <code class="language-plaintext highlighter-rouge">f</code> accepts <code class="language-plaintext highlighter-rouge">w</code>, the generated function accepts <em>all strings</em> passed to it. Since the set of all strings is a regular language, the generated function recognizes a regular language. When <code class="language-plaintext highlighter-rouge">f</code> does not accept <code class="language-plaintext highlighter-rouge">w</code>, the function accepts all strings that match the pattern 0<sup><em>n</em></sup>1<sup><em>n</em></sup>, but for all other strings it will either reject or loop. In other words, it recognizes a non-regular language. Therefore, our implementation fulfills the contract we specified earlier. If we come back to our unit tests and replace the mocks with <code class="language-plaintext highlighter-rouge">nonRegularOrDelegate</code> in all cases, they should all pass.</p>

<h2 id="contradiction">Contradiction</h2>

<p>Let’s recap what we’ve done so far: we are assuming that there is a decider for regular languages out there in the world. We imported that decider and, with just a few lines of simple code around it, we managed to implement a function that can tell wether another function accepts a given string.</p>

<p>But here’s the contradiction: a function like <code class="language-plaintext highlighter-rouge">UniversalDecider</code> does not, and cannot, exist (to understand why, wait for the second part of this post). How is this possible? We have certainly built this function. Its implementation is clear and simple. There are even unit tests to prove that it works, in case there were any doubts. So there remains only one possibility: our assumption that there exists a decider for regular languages is false: it’s impossible to implement a function that can tell whether another function recognizes a regular language!</p>

<p>This result can be disheartening, because it shows some computational limits involving things that are as familiar as regular expressions. On the other hand, there is a sort of logical beauty to this construction that fascinates me every time I think about it. The complete source code is <a href="https://github.com/otaviomacedo/turing">here</a>.</p>

<hr />
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Note about convention: we are only interested in boolean functions in this article. So, every time you see a mention to a function, I implictly mean a function that returns <code class="language-plaintext highlighter-rouge">Boolean</code>. Also, for simplicity, strings can only contain the characters <code class="language-plaintext highlighter-rouge">'0'</code> or <code class="language-plaintext highlighter-rouge">'1'</code>. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div><a class="u-url" href="/decidability/2020/12/11/regex.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Otavio Macedo</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Otavio Macedo</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/otaviomacedo"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">otaviomacedo</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
